---
description: 重述需求，评估风险，并制定分步实施计划。在触碰任何代码之前等待用户确认。
---

# 计划命令 (Plan Command)

此命令调用 **planner** (计划者) agent，在编写任何代码之前创建全面的实施计划。

## 此命令做什么

1. **重述需求** - 阐明需要构建的内容
2. **识别风险** - 暴露潜在问题和阻碍
3. **创建步骤计划** - 将实施分解为多个阶段
4. **等待确认** - 在继续之前必须获得用户批准

## 何时使用

在以下情况下使用 `/plan`：
- 开始新功能时
- 进行重大架构更改时
- 处理复杂的重构时
- 将影响多个文件/组件时
- 需求不清楚或模棱两可时

## 工作原理

Planner agent 将：

1. **分析请求** 并用清晰的术语重述需求
2. **分解为阶段**，包含具体、可操作的步骤
3. **识别依赖关系** 组件之间的依赖
4. **评估风险** 和潜在阻碍
5. **估算复杂度** (高/中/低)
6. **展示计划** 并等待您的明确确认

## 示例用法

```
User: /plan 我需要添加当市场解决时的实时通知功能

Agent (planner):
# 实施计划：实时市场解决通知

## 需求重述
- 当用户关注的市场解决时发送通知
- 支持多种通知渠道（应用内、邮件、Webhook）
- 确保通知可靠投递
- 包含市场结果和用户的持仓结果

## 实施阶段

### 第一阶段：数据库模式
- 添加 notifications 表，包含字段：id, user_id, market_id, type, status, created_at
- 添加 user_notification_preferences 表用于渠道偏好
- 为性能在 user_id 和 market_id 上创建索引

### 第二阶段：通知服务
- 在 lib/notifications.ts 中创建通知服务
- 使用 BullMQ/Redis 实现通知队列
- 为失败的投递添加重试逻辑
- 创建通知模板

### 第三阶段：集成点
- 挂钩到市场解决逻辑（当状态变为 "resolved" 时）
- 查询所有在该市场有持仓的用户
- 为每个用户将通知入队

### 第四阶段：前端组件
- 在页眉中创建 NotificationBell 组件
- 添加 NotificationList 模态框
- 通过 Supabase 订阅实现实时更新
- 添加通知偏好设置页面

## 依赖
- Redis (用于队列)
- Email 服务 (SendGrid/Resend)
- Supabase 实时订阅

## 风险
- 高：邮件送达率 (需要 SPF/DKIM)
- 中：每个市场 1000+ 用户时的性能
- 中：如果市场频繁解决导致的通知垃圾邮件
- 低：实时订阅开销

## 估算复杂度：中 (MEDIUM)
- 后端：4-6 小时
- 前端：3-4 小时
- 测试：2-3 小时
- 总计：9-13 小时

**等待确认**：按此计划进行吗？(yes/no/modify)
```

## 重要提示

**严重 (CRITICAL)**：Planner agent **不会**编写任何代码，直到您通过 "yes" 或 "proceed" 或类似的肯定回复明确确认计划。

如果您想要更改，请回复：
- "modify: [您的更改]"
- "different approach: [替代方案]"
- "skip phase 2 and do phase 3 first" (跳过阶段 2，先做阶段 3)

## 与其他命令集成

计划之后：
- 使用 `/tdd` 进行测试驱动开发
- 如果出现构建错误，使用 `/build-and-fix`
- 使用 `/code-review` 审查已完成的实施

## 相关 Agent

此命令调用位于此处的 `planner` agent：
`~/.claude/agents/planner.md`
